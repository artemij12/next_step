#include "setup.h"
u_int count_of_rotation = 0;//количество прерываний оптопары (ввел псевдоним u_int это unsigned int) 
//float time_of_rotation = 0.0;//время прерывания оптопары
 //текущий пункт меню, хотя их у нас пока 2, но потом можем расширять, byte это unsigned char
float litres=0.0; //количество литров, что будет выводиться на экран (можети не понадобится)
char rezhim[] = {'U','W','R'};
byte mode=0;
save_data S_D[10];
digitalPinToInterrupt(pin)
volatile bool IntFlag=false;//флаг прерывания на кнопке Пуск/Сет, ловим нажатие во время юстировки или работы
//нужно за тем, что мы не знаем когда закончится пролив жидкости
/*enum rezhim
{
U = 0 ,W = 1 ,R = 2 
};//перечисляемый тип устанавливаем в работу 
rezhim mode = U;*/
void setup()
{
lcd.init();
lcd.backlight();
lcd.setCursor(0,0);
pinMode(opt_pin,INPUT);//установка ножки камня на чтение сигналов из оптопары
pinMode(set_pin,INPUT);
pinMode(pusk_pin,INPUT);
}
void PushInt() //прерывание устанвливает флаг в false
{
 IntFlag=false;
}
byte push_btn(byte pin_)//  
{
 int Min_t=millis();
  while ((millis()-Min_t)<Time_Hold) // в цикле считаем до времени после которого считается зажим клавиши
    {
      if (digitalRead(pin_)==0)// если кнопку отпустили в течении Time_Hold
      {
        if ((millis()-Min_t) < Min_push) return 0; //если прошло времени меньше, чем Min_push, значит дребезг
        else return 1; //Это значит кратковременное нажатие
      }
    }
  return 2; // Зажали кнопку
//Если клавиша нажата долго возвращем например 2 , т.е. счетчик досчитал до конца 
//если нажата не долго 1
//  дребезг или просто не нажата 0
}
void print_char(byte ch)//c функция печати пункта меню
{

  switch(ch)
  {
    case 0:
        lcd.print("U");
        delay(100);
        lcd.clear();
    case 1:
        lcd.print("W");
        delay(100);
        lcd.clear();
    case 2:
        lcd.print("R");
        delay(100);
        lcd.clear();

  
 }
// Взависимости от значения с выводим на экран U/W/R(резет потом скидываем и вовращаемся в режим W)
}
void print_cyf(float f)// функция только выводит на экран цифры
{
lcd.setCursor(0,1);
float litres_prom = 0.0;
switch (push_btn(set_pin))//эта функция работает так, что пока кнопка set отжата значение для юстировки увеличивается
{                         //в случае ее кратковременного нажатия происходит остановка увеличения цифр   
  case 0:                 //значения записываются в переменные а при длительном нажатии обнуляются
  litres_prom+=0.1;
  lcd.print(litres);
  //delay(10);
  lcd.clear();
  case 1:
    litres = litres_prom;
    lcd.print(litres);
    delay(100);
    lcd.clear();
    break;
  case 2:
    litres = 0;
    litres_prom = 0;
    lcd.print(String(f));
}
}
void start_inr() //устанавливаем прерывание , данные берем из setup.h
{

}
void stop_inr() // убираем прерывание....Можно конечно и в цикле loop все это написать, но функциями сподручнее
{

}
u_int time_and_count (float &time_of_close, &float time_of_open) 
{ 
  u_int count_of_rot=0;
 attachInterrupt(0, IntPush , CHANGE);
 IntFlag=true;
 while(IntFlag)
  if(pulseIn(opt_pin,LOW)!=0)
  {
    time_of_close += pulseIn(opt_pin,LOW);
    count_of_rot++;
  }
  if(pulseIn(opt_pin,HIGH)!=0)
  {
    time_of_open += pulseIn(opt_pin,HIGH);
    count_of_rot++;
  }
return count_of_rot;
dettachInterrupt(0, IntPush , CHANGE); 
//в этой функции будет реализован подсчет количества оборотов крыльчатки и времени, на которое прерывается оптопара
}
void loop () 
{
 int flag=0;
 flag=push_btn(set_pin);
 flag|=push_btn(pusk_pin);
 if(!flag)
    switch(curpos)
    {
      case 1:
      {
        if (flag&1<<4)//проверка бита флага нажатие кн. set 1<<4 10xx & 1000 = 1000
      {
        if (mode<=2)mode++;
        else mode=0;
      }
      if (flag&1<<3)//проверка бита флага нажатия кнопки push
      {
        if (mode==0) curpos=2;//попадаем в п. меню 2 это режим "U" вывод 00.00 на экран и ввод литров для юстировки
        if (mode==1) curpos=3;//покадаем в п. меню 3 это режим "W" где мы до нажатия кнопки Пуск льем бензин
       } 
      print_char(mode); 
      }break;
      case 2://нажали кнопку сет при юстировке
      {
        print_cyf(litres);
        if(flag&1<<3 and flag&1<<2) {litres=0.0; curpos=1;mode=0;break;}// если кнопка Пуск зажата сбрасываем счетчик
        if(flag&1<<4)// если кнопка сет нажата/зажата
                { 
          while(digitalRead(set_pin))
          { if(litres<99.98) litres+=0.01;
            else litres=99.99;
            lcd.print(litres);
           }
        }
        if(flag&1<<3)  // нажата кнопка Пуск
        {
          if (litres==0.0) break;
          else curpos=4;
        }
      }break;
      case 3: // Режим ar
      {
          if (flag&1<<3) time_and_count();
          if (flag&1<<3 and flag<<2) {lcd.print(0.0);curpos=1;mode=1;}
      } break;
      case 4:
       if (flag&1<<3 or ) 
      
    }
    

      
  }  
//здесь реализуем бесконечный цикл обработки нажатий клавиш
// тут будет простая лесенка операторов выбора вида if push_set() { ....} else
// или в принципе switch...case... еще удобно делать бесконечные циклы типа while True с выходом по break; Ни кто не мешает комбинировать
// так же напомню, что в Си 0 это False, любое отрицательное число False , также очень удобны конструкции типа if push_pusk()&&R==work {...}
// тут логическое И применяется к двум результатам возвращаемого значения функции pusk_push() и результат сравнения переменной R с перечисляемым типом
bool f_reset(u_int t) // функция зажима клавиши Пуск/Стоп длинное зажатие будет означать FALSE т.е. сброс значений неважно чего
{
// функция вряд ли понадобиться в качестве отдельной, если есть желание , то можно вызывать ее из функций push_set, push_pusk... код повторяется. можно
 // и вынести в отдельную функцию
}
short speed_calc()//она должна уже возвращать количество литров
{
//эта функция вызывается по прерыванию, когда тикнул таймер, она высчитывает на основании глобальных пременных объявленных в setup() количество вращений крыльчатки и затем
// она берет данные юстировки, где известно, что определенное количество оборотов крыльчатки соответсвует определенному количеству жидкости прошедшей через трубу
//таких функций можно наделать много и матаппарат еще придется допиливать напильником, но он простой....и чем больше таких функций, тем точнее будет матмодель  
//пока надо сделать грубую модель, а вот ее улучшать как мне видится можно математикой
}
void rezult(){
// вывод результата измерений объема жидкости
}
void math_model()
{
}// это штука на будущее...отдельно от обработчиков надо создать матмодель, в которую мы передаем данные (скорей всего в структурах struct) и она уже считает все как надо
void save_rez(short ob, short kolvj, float l)//кол-во оборотов, время открытия закрытия и кол-во жидкости
{
//создаем условную табличку в EEPROM...Упакованную ...2 байта на каждую переменную...Читать легко, записывать еще проще..
}
bool reset_save_rez(){
//очистка значений таблицы юстировки логический тип возвращаемого значения нужен для того, чтобы вывести результат работы функции и вывести его на экран 
}
void print_rez_of_reset_1(){
//вывод надписи об успешной очистке EEPROM
}
void print_rez_of_reset_2(){
//вывод надписи в случае не успешной очистки EEPROM
}
// Это пока в общих чертах на сутках накидал на листочке(так лучше думается )))) и перебил в цифру...Это еще просто наработка....Вообще если под один камень писать, тут есть где разгуляться ассму...
//Но лучше Си....масштабируемость даже близко не сравнима

// 0000 3 2 1 0 // 1 0- 00 - нет нажатия , 0 1 - коротко , 1 0 - зажата 
// 3 - set , 2 -pusk
