#include "setup.h"
u_int count_of_rotation = 0;//количество прерываний оптопары (ввел псевдоним u_int это unsigned int) 
float time_of_rotation = 0.0;//время прерывания оптопары
 //текущий пункт меню, хотя их у нас пока 2, но потом можем расширять, byte это unsigned char
float litres=0.0; //количество литров, что будет выводиться на экран (можети не понадобится)
enum rezhim
{
U = 0,W = 1,R = 2
};//перечисляемый тип устанавливаем в работу 
rezhim mode = U;
void setup()
{
lcd.init();
lcd.backlight();
lcd.setCursor(0,0);
pinMode(opt_pin,INPUT);//установка ножки камня на чтение сигналов из оптопары
pinMode(set_pin,INPUT);
pinMode(pusk_pin,INPUT);
byte mode=1;
}
byte push_btn(byte pin_)//  
{
 int Min_t=millis();
  while ((millis()-Min_t)<Time_Hold) // в цикле считаем до времени после которого считается зажим клавиши
    {
      if (digitalRead(pin_)==0)// если кнопку отпустили в течении Time_Hold
      {
        if ((millis()-Min_t) < Min_push) return 0; //если прошло времени меньше, чем Min_push, значит дребезг
        else return 1; //Это значит кратковременное нажатие
      }
    }
  return 2; // Зажаликнопку
//Если клавиша нажата долго возвращем например 2 , т.е. счетчик досчитал до конца 
//если нажата не долго 1
//  дребезг или просто не нажата 0
}
void print_char(byte c)// функция печати пункта меню
{
 for(int i = 0;i <= 2;i++)
 {
  switch(i)
  {
    case 0:
        lcd.print("U");
        delay(100);
        lcd.clear();
    case 1:
        lcd.print("W");
        delay(100);
        lcd.clear();
    case 2:
        lcd.print("R");
        delay(100);
        lcd.clear();

  }
 }
// Взависимости от значения с выводим на экран U/W/R(резет потом скидываем и вовращаемся в режим W)
}
void print_cyf()
{
lcd.setCursor(0,1);
float litres_prom = 0.0;
switch (push_btn(set_pin))//эта функция работает так, что пока кнопка set отжата значение для юстировки увеличивается
{                         //в случае ее кратковременного нажатия происходит остановка увеличения цифр   
  case 0:                 //значения записываются в переменные а при длительном нажатии обнуляются
  litres_prom+=0.1;
  lcd.print(litres);
  //delay(10);
  lcd.clear();
  case 1:
    litres = litres_prom;
    lcd.print(litres);
    delay(100);
    lcd.clear();
    break;
  case 2:
    litres = 0;
    litres_prom = 0;
    lcd.print(String(litres)+" "+String(litres_prom));
}
}
void start_inr() //устанавливаем прерывание , данные берем из setup.h
{

}
void stop_inr() // убираем прерывание....Можно конечно и в цикле loop все это написать, но функциями сподручнее
{

}
void count_rot_time()
{
  time_of_rotation+=pulseIn(opt_pin,LOW)*0.000001;
  if(pulseIn(opt_pin,LOW)!=0)
  {
    count_of_rotation++;
  }
//в этой функции будет реализован подсчет количества оборотов крыльчатки и времени, на которое прерывается оптопара
}
void loop () 
{
 print_char(mode); // начинаем вывод режимов работы
  switch(mode)
  {
    case 0:
      switch(push_btn(pusk_pin))//цифры появились на экране и сохранились в переменную litres
      {
        case 0:
        break;
        case 1:
        print_cyf();//после кратковременного нажатия идет зажим кнопки pusk и проливание воды без отжатия кнопки для того, чтобы не выйти 
        case 2:     // из case2
        count_rot_time();
      }
    save_rez(litres,short(count_of_rotation));
    

      
  } 
  }  
//здесь реализуем бесконечный цикл обработки нажатий клавиш
// тут будет простая лесенка операторов выбора вида if push_set() { ....} else
// или в принципе switch...case... еще удобно делать бесконечные циклы типа while True с выходом по break; Ни кто не мешает комбинировать
// так же напомню, что в Си 0 это False, любое отрицательное число False , также очень удобны конструкции типа if push_pusk()&&R==work {...}
// тут логическое И применяется к двум результатам возвращаемого значения функции pusk_push() и результат сравнения переменной R с перечисляемым типом
bool f_reset(u_int t) // функция зажима клавиши Пуск/Стоп длинное зажатие будет означать FALSE т.е. сброс значений неважно чего
{
// функция вряд ли понадобиться в качестве отдельной, если есть желание , то можно вызывать ее из функций push_set, push_pusk... код повторяется. можно
 // и вынести в отдельную функцию
}
short speed_calc()//она должна уже возвращать количество литров
{
//эта функция вызывается по прерыванию, когда тикнул таймер, она высчитывает на основании глобальных пременных объявленных в setup() количество вращений крыльчатки и затем
// она берет данные юстировки, где известно, что определенное количество оборотов крыльчатки соответсвует определенному количеству жидкости прошедшей через трубу
//таких функций можно наделать много и матаппарат еще придется допиливать напильником, но он простой....и чем больше таких функций, тем точнее будет матмодель  
//пока надо сделать грубую модель, а вот ее улучшать как мне видится можно математикой
}
void rezult(){
// вывод результата измерений объема жидкости
}
void math_model()
{
}// это штука на будущее...отдельно от обработчиков надо создать матмодель, в которую мы передаем данные (скорей всего в структурах struct) и она уже считает все как надо
void save_rez(short ob, short kolvj)
{
//создаем условную табличку в EEPROM...Упакованную ...2 байта на каждую переменную...Читать легко, записывать еще проще..
}
bool reset_save_rez(){
//очистка значений таблицы юстировки логический тип возвращаемого значения нужен для того, чтобы вывести результат работы функции и вывести его на экран 
}
void print_rez_of_reset_1(){
//вывод надписи об успешной очистке EEPROM
}
void print_rez_of_reset_2(){
//вывод надписи в случае не успешной очистки EEPROM
}
// Это пока в общих чертах на сутках накидал на листочке(так лучше думается )))) и перебил в цифру...Это еще просто наработка....Вообще если под один камень писать, тут есть где разгуляться ассму...
//Но лучше Си....масштабируемость даже близко не сравнима

