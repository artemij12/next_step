#include "setup.h"
unsigned int count_of_rotation = 0;//количество прерываний оптопары (ввел псевдоним u_int это unsigned int) 
float time_of_rotation = 0;//время прерывания оптопары
 //текущий пункт меню, хотя их у нас пока 2, но потом можем расширять, byte это unsigned char
float litres=0.0; //количество литров, что будет выводиться на экран (можети не понадобится)
enum rezhim
{
U = 0,W = 1,R = 2
};//перечисляемый тип устанавливаем в работу 
rezhim mode = U;
void setup()
{
pinMode(opt_pin,INPUT);//установка ножки камня на чтение сигналов из оптопары
pinMode(set_pin,INPUT);
pinMode(pusk_pin,INPUT);
byte mode=1;
}
byte push_btn(byte pin_)//  
{
 int Min_t=millis();
  while ((millis()-Min_t)<Time_Hold) // в цикле считаем до времени после которого считается зажим клавиши
    {
      if (digitalRead(pin_)==0)// если кнопку отпустили в течении Time_Hold
      {
        if ((millis()-Min_t) < Min_push) return 0; //если прошло времени меньше, чем Min_push, значит дребезг
        else return 1; //Это значит кратковременное нажатие
      }
    }
  return 2; // Зажаликнопку
//Если клавиша нажата долго возвращем например 2 , т.е. счетчик досчитал до конца 
//если нажата не долго 1
//  дребезг или просто не нажата 0
}
/*bool push_set()
{
//считываем уровень сигнала на пине кнопки, если низкий уровень меньше времени min_push(выдежка,убираем дребезг контактов) сразу возвращаем False , иначе True
  // функция millis() возвращает время из регистра который считает время с начала вкючения ардуинкипо большому счету считает тики камня и когда переполняется обнуляется и заново
  // но т.к. регистр здоровый там на несколько недель по-моему 
  int Min_t=millis();
  while ((millis()-Min_t)<Min_push)
    {
      if (digitalRead(set_pin)==0) return False;
    }
  return True;
}*/
void print_char(byte c)// функция печати пункта меню
{
 for(int i = 0;i <= 2;i++)
 {
  switch(i)
  {
    case 0:
        lcd.print("U");
        delay(100);
        lcd.clear();
    case 1:
        lcd.print("W");
        delay(100);
        lcd.clear();
    case 2:
        lcd.print("R");
        delay(100);
        lcd.clear();
  
  }
 }
// Взависимости от значения с выводим на экран U/W/R(резет потом скидываем и вовращаемся в режим W)
}
void print_cyf(byte i)
{
//Функция вывода на экран цифр, выводим i переведя его в строку 
}
void start_inr() //устанавливаем прерывание , данные берем из setup.h
{
}
void stop_inr() // убираем прерывание....Можно конечно и в цикле loop все это написать, но функциями сподручнее
{
}
void count_rot()
{
//в этой функции будет реализован подсчет количества оборотов крыльчатки и времени, на которое прерывается оптопара
}
void loop () 
{
 print_char(mode); // начинаем вывод режимов работы
  switch(mode)
  {
    case 0:
      switch(push_btn(set_pin))
      {
        case 0:
        break;
        case 1:
        
      }
  }

            
          
      

      

     
    
    
  }  
//здесь реализуем бесконечный цикл обработки нажатий клавиш
// тут будет простая лесенка операторов выбора вида if push_set() { ....} else
// или в принципе switch...case... еще удобно делать бесконечные циклы типа while True с выходом по break; Ни кто не мешает комбинировать
// так же напомню, что в Си 0 это False, любое отрицательное число False , также очень удобны конструкции типа if push_pusk()&&R==work {...}
// тут логическое И применяется к двум результатам возвращаемого значения функции pusk_push() и результат сравнения переменной R с перечисляемым типом
bool f_reset(u_int t) // функция зажима клавиши Пуск/Стоп длинное зажатие будет означать FALSE т.е. сброс значений неважно чего
{
// функция вряд ли понадобиться в качестве отдельной, если есть желание , то можно вызывать ее из функций push_set, push_pusk... код повторяется. можно
 // и вынести в отдельную функцию
}
short speed_calc()//она должна уже возвращать количество литров
{
//эта функция вызывается по прерыванию, когда тикнул таймер, она высчитывает на основании глобальных пременных объявленных в setup() количество вращений крыльчатки и затем
// она берет данные юстировки, где известно, что определенное количество оборотов крыльчатки соответсвует определенному количеству жидкости прошедшей через трубу
//таких функций можно наделать много и матаппарат еще придется допиливать напильником, но он простой....и чем больше таких функций, тем точнее будет матмодель  
//пока надо сделать грубую модель, а вот ее улучшать как мне видится можно математикой
}
void rezult(){
// вывод результата измерений объема жидкости
}
void math_model()
{
}// это штука на будущее...отдельно от обработчиков надо создать матмодель, в которую мы передаем данные (скорей всего в структурах struct) и она уже считает все как надо
void save_rez(short ob, short kolvj, short koeff)
{
//создаем условную табличку в EEPROM...Упакованную ...2 байта на каждую переменную...Читать легко, записывать еще проще..
}
bool reset_save_rez(){
//очистка значений таблицы юстировки логический тип возвращаемого значения нужен для того, чтобы вывести результат работы функции и вывести его на экран 
}
void print_rez_of_reset_1(){
//вывод надписи об успешной очистке EEPROM
}
void print_rez_of_reset_2(){
//вывод надписи в случае не успешной очистки EEPROM
}
// Это пока в общих чертах на сутках накидал на листочке(так лучше думается )))) и перебил в цифру...Это еще просто наработка....Вообще если под один камень писать, тут есть где разгуляться ассму...
//Но лучше Си....масштабируемость даже близко не сравнима

